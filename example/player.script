local client = require("example.client")

go.property("local_player", true)
go.property("player_nr", 0)

local GRAVITY = -1
local MOVEMENT_SPEED = 5
local ROTATION_SPEED = 2
local JUMP_SPEED = 20

local ANIM_IDLE = "Idle"
local ANIM_WALK = "Walking_A"
local ANIM_ATTACK = "1H_Melee_Attack_Chop"
local ANIM_JUMP_START = "Jump_Start"

local EVENT_TRANSFORM = "transform"
local EVENT_FORWARD = "forward"
local EVENT_TURN = "turn"
local EVENT_ATTACK = "attack"
local EVENT_JUMP = "jump"

local ACTION_LEFT = hash("left")
local ACTION_RIGHT = hash("right")
local ACTION_FORWARD = hash("forward")
local ACTION_BACK = hash("back")
local ACTION_JUMP = hash("jump")
local ACTION_ATTACK = hash("attack")

local MSG_CONTACT_POINT_RESPONSE = hash("contact_point_response")
local MSG_COLLISION_RESPONSE = hash("collision_response")
local MSG_MESSAGE_RECEIVED = hash("MessageReceived")

local FORWARD_VECTOR = vmath.vector3(0, 0, 1)

local function play_animation(self, id, playback)
	if self.animation ~= id then
		local previous = self.animation
		local previous_playback = self.animation_playback
		self.animation = id
		self.animation_playback = playback
		model.play_anim("model#model", id, playback or go.PLAYBACK_LOOP_FORWARD, nil, function()
			self.animation = previous
			model.play_anim("model#model", previous, previous_playback or go.PLAYBACK_LOOP_FORWARD)
		end)
	end
end

local function turn(self, value)
	self.rotation = value
	if self.local_player then
		odin.send(json.encode({ id = EVENT_TURN, value = value }))
	end
end

local function move(self, value)
	if value == 0 then
		play_animation(self, ANIM_IDLE)
	else
		play_animation(self, ANIM_WALK)
	end
	self.forward = value
	if self.local_player then
		odin.send(json.encode({ id = EVENT_FORWARD, value = value }))
	end
end

local function attack(self)
	play_animation(self, ANIM_ATTACK, go.PLAYBACK_ONCE_FORWARD)
	if self.local_player then
		odin.send(json.encode({ id = EVENT_ATTACK }))
	end
end

local function jump(self, speed)
	if self.ground_contact then
		self.velocity.y = speed
		self.ground_contact = false
		play_animation(self, ANIM_JUMP_START, go.PLAYBACK_ONCE_FORWARD)
		if self.local_player then
			odin.send(json.encode({ id = EVENT_JUMP, speed = speed }))
		end
	end
end

local function handle_message(self, event, data)
	if event == EVENT_TRANSFORM then
		go.set(".", "position.x", data.x)
		go.set(".", "position.y", data.y)
		go.set(".", "position.z", data.z)
		go.set("model", "euler.y",  data.roty)
	elseif event == EVENT_FORWARD then
		move(self, data.value)
	elseif event == EVENT_TURN then
		turn(self, data.value)
	elseif event == EVENT_ATTACK then
		attack(self)
	elseif event == EVENT_JUMP then
		jump(self, data.speed)
	end
end


function init(self)
	-- rotation around the y-axis
	-- positive value = rotate clockwise, negative value = rotate counter clockwise, 
	self.rotation = 0

	-- movement in direction
	-- positive value = move forward, negative value = move backwards
	self.forward = 0

	self.velocity = vmath.vector3()

	-- for resolving physics collisions
	self.correction = vmath.vector3()

	-- currently played animation
	self.animation = nil

	play_animation(self, ANIM_IDLE)

	-- enabled and disable meshes to get the correct look
	-- weapons
	model.set_mesh_enabled("model#model", "1H_Sword", true)
	model.set_mesh_enabled("model#model", "1H_Sword_Offhand", false)
	model.set_mesh_enabled("model#model", "2H_Sword", false)

	-- equipment
	model.set_mesh_enabled("model#model", "Knight_Helmet", false)
	model.set_mesh_enabled("model#model", "Knight_Cape", false)

	-- different shields
	model.set_mesh_enabled("model#model", "Spike_Shield", true)
	model.set_mesh_enabled("model#model", "Round_Shield", false)
	model.set_mesh_enabled("model#model", "Rectangle_Shield", false)
	model.set_mesh_enabled("model#model", "Badge_Shield", false)

	if self.local_player then
		msg.post(".", "acquire_input_focus")
		go.set_parent("/camera", go.get_id())
		-- send position and rotation every 0.5 seconds
		-- not that rotation and forward movement is sent in
		-- on_input as soon as it happens
		self.timerh = timer.delay(0.5, true, function()
			local pos = go.get_position()
			local data = {
				id = EVENT_TRANSFORM,
				x = pos.x,
				y = pos.y,
				z = pos.z,
				roty = go.get("model", "euler.y")
			}
			odin.send(json.encode(data))
		end)
	else
		client.subscribe(msg.url())
	end
end

function final(self)
	if self.local_player then
		go.set_parent("/camera", nil, true)
		timer.cancel(self.timerh)
	else
		client.unsubscribe(msg.url())
	end
end

function update(self, dt)
	-- rotate model object around the y-axis
	local rot = go.get_rotation("model")
	rot = rot * vmath.quat_rotation_y(ROTATION_SPEED * -self.rotation * dt)
	go.set_rotation(rot, "model")

	-- move in direction of facing
	local dir = vmath.rotate(rot, FORWARD_VECTOR * self.forward * MOVEMENT_SPEED)

	-- set velocity along the flow based on movement direction
	-- also add gravity if in the air
	self.velocity.x = dir.x
	self.velocity.z = dir.z
	if not self.ground_contact then
		self.velocity.y = self.velocity.y + GRAVITY
	end

	-- update position
	local pos = go.get_position()
	pos = pos + self.velocity * dt
	go.set_position(pos)

	-- reset volatile variables
	self.correction = vmath.vector3()
	self.ground_contact = false
end

function on_message(self, message_id, message, sender)
	if message_id == MSG_CONTACT_POINT_RESPONSE then
		-- https://defold.com/manuals/physics-resolving-collisions/
		if message.distance > 0 then
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				local comp = (message.distance - message.distance * proj) * message.normal
				go.set_position(go.get_position() + comp)
				self.correction = self.correction + comp
			end
		end
		-- check for ground contact
		-- clear vertical velocity if falling
		if message.other_group == hash("floor") then
			if self.velocity.y <= 0 then
				self.velocity.y = 0
				self.ground_contact = true
			end
		end
	elseif message_id == MSG_COLLISION_RESPONSE then
		-- no-op
	elseif message_id == MSG_MESSAGE_RECEIVED then
		if self.player_nr == message.sender_peer_id then
			local data = json.decode(message.message)
			handle_message(self, data.id, data)
		end
	end
end


function on_input(self, action_id, action)
	if action_id == ACTION_LEFT then
		if action.pressed then
			turn(self, -1)
		elseif action.released then
			turn(self, 0)
		end
	elseif action_id == ACTION_RIGHT then
		if action.pressed then
			turn(self, 1)
		elseif action.released then
			turn(self, 0)
		end
	elseif action_id == ACTION_FORWARD then
		if action.pressed then
			move(self, 1)
		elseif action.released then
			move(self, 0)
		end
	elseif action_id == ACTION_BACK then
		if action.pressed then
			move(self, -1)
		elseif action.released then
			move(self, 0)
		end
	elseif action_id == ACTION_ATTACK then
		if action.pressed then
			attack(self)
		end
	elseif action_id == ACTION_JUMP then
		if action.pressed then
			jump(self, JUMP_SPEED)
		end
	end
end
